{"remainingRequest":"/Users/mdzz/Desktop/公开课/node_modules/_vue-loader@15.9.7@vue-loader/lib/index.js??vue-loader-options!/Users/mdzz/Desktop/公开课/src/App.vue?vue&type=style&index=0&lang=less&","dependencies":[{"path":"/Users/mdzz/Desktop/公开课/src/App.vue","mtime":1621159727927},{"path":"/Users/mdzz/Desktop/公开课/node_modules/_css-loader@3.6.0@css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/mdzz/Desktop/公开课/node_modules/_vue-loader@15.9.7@vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/mdzz/Desktop/公开课/node_modules/_postcss-loader@3.0.0@postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/mdzz/Desktop/公开课/node_modules/_less-loader@5.0.0@less-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/mdzz/Desktop/公开课/node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/mdzz/Desktop/公开课/node_modules/_vue-loader@15.9.7@vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgpkaXYgewogIHdpZHRoOiA4MHB4OwogIGhlaWdodDogOTBweDsKICBiYWNrZ3JvdW5kOiBvcmFuZ2U7CiAgcG9zaXRpb246IGFic29sdXRlOwogIGxlZnQ6IDA7Cn0K"},{"version":3,"sources":["App.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DA;AACA;AACA;AACA;AACA;AACA;AACA","file":"App.vue","sourceRoot":"src","sourcesContent":["<template>\n  <div id=\"app\"></div>\n</template>\n\n<script>\nexport default {\n  mounted() {\n    let box = document.querySelector(\"#app\"),\n      minL = 0,\n      maxL = document.documentElement.clientWidth - box.offsetWidth,\n      direction = \"right\",\n      step = 10,\n      timer = null;\n    function move() {\n      // 获取当前的位置 在这个基础上 向左或向右移动\n      let curL = parseFloat(getComputedStyle(box)[\"left\"]);\n      if (direction == \"right\") {\n        curL += step;\n        if (curL >= maxL) {\n          curL = maxL;\n          direction = \"left\";\n        }\n      } else {\n        curL -= step;\n        if (curL <= minL) {\n          curL = minL;\n          direction = \"right\";\n        }\n      }\n      box.style.left = `${curL}px`;\n      timer = requestAnimationFrame(move);\n    }\n    //  timer = setInterval(move, 5);\n    timer = requestAnimationFrame(move);\n    /* \n      60HZ 一秒钟刷新60次 即16.7ms刷新一次 才能看到最新的效果\n      元素 5ms运动一次\n        开始 0 \n        5ms 位置10\n        10ms 位置20 \n        15ms 位置30 「此时已经运动3次了 但是屏幕16.7ms刷新一次 所以看不到效果」\n         --- 到达16.7ms刷新一次 位置直接蹦到了30 跳过了规定的step为10看到的效果 所以定时器动画会卡顿/抖动/丢帧---\n        20ms 位置40 \n\n        还有一个原因是定时器是异步宏任务，可能会不准时。\n        使用 requestAnimationFrame 替代\n          - 由系统决定回调函数的执行时机\n          - 当页面最小化/路由跳转时 requestAnimationFrame不会被执行 而定时器会被执行\n            requestAnimationFrame 只有在页面激活状态才会被执行\n          - 函数截流：回调函数在屏幕每一次刷新间隔中只执行一次\n          - 集中处理改变样式：将每一贞的样式改变收集起来 在一次回流/重绘中完成\n            在隐藏或者不可见的元素中 将不会进行回流/重绘\n          - 为了兼容处理 不支持requestAnimationFrame情况下 定时器动画时间一般写 16.7 \n      \n      requestIdleCallback:在浏览器空闲的时候调用回调函数，这样一些不重要的任务可以延后执行\n                          防止页面卡顿，只有新版浏览器才支持。\n    */\n  },\n};\n</script>\n\n<style lang=\"less\">\ndiv {\n  width: 80px;\n  height: 90px;\n  background: orange;\n  position: absolute;\n  left: 0;\n}\n</style>"]}]}